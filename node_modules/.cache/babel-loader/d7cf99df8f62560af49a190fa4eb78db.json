{"ast":null,"code":"// Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment\nconst INDENT_REGEX = /^(?:( )+|\\t+)/;\nconst INDENT_TYPE_SPACE = 'space';\nconst INDENT_TYPE_TAB = 'tab';\n/**\nMake a Map that counts how many indents/unindents have occurred for a given size and how many lines follow a given indentation.\n\nThe key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.\n\n```\nindents = {\n\tt3: [1, 0],\n\tt4: [1, 5],\n\ts5: [1, 0],\n\ts12: [1, 0],\n}\n```\n*/\n\nfunction makeIndentsMap(string, ignoreSingleSpaces) {\n  const indents = new Map(); // Remember the size of previous line's indentation\n\n  let previousSize = 0;\n  let previousIndentType; // Indents key (ident type + size of the indents/unindents)\n\n  let key;\n\n  for (const line of string.split(/\\n/g)) {\n    if (!line) {\n      // Ignore empty lines\n      continue;\n    }\n\n    let indent;\n    let indentType;\n    let weight;\n    let entry;\n    const matches = line.match(INDENT_REGEX);\n\n    if (matches === null) {\n      previousSize = 0;\n      previousIndentType = '';\n    } else {\n      indent = matches[0].length;\n      indentType = matches[1] ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB; // Ignore single space unless it's the only indent detected to prevent common false positives\n\n      if (ignoreSingleSpaces && indentType === INDENT_TYPE_SPACE && indent === 1) {\n        continue;\n      }\n\n      if (indentType !== previousIndentType) {\n        previousSize = 0;\n      }\n\n      previousIndentType = indentType;\n      weight = 0;\n      const indentDifference = indent - previousSize;\n      previousSize = indent; // Previous line have same indent?\n\n      if (indentDifference === 0) {\n        weight++; // We use the key from previous loop\n      } else {\n        const absoluteIndentDifference = indentDifference > 0 ? indentDifference : -indentDifference;\n        key = encodeIndentsKey(indentType, absoluteIndentDifference);\n      } // Update the stats\n\n\n      entry = indents.get(key);\n      entry = entry === undefined ? [1, 0] : [++entry[0], entry[1] + weight];\n      indents.set(key, entry);\n    }\n  }\n\n  return indents;\n} // Encode the indent type and amount as a string (e.g. 's4') for use as a compound key in the indents Map.\n\n\nfunction encodeIndentsKey(indentType, indentAmount) {\n  const typeCharacter = indentType === INDENT_TYPE_SPACE ? 's' : 't';\n  return typeCharacter + String(indentAmount);\n} // Extract the indent type and amount from a key of the indents Map.\n\n\nfunction decodeIndentsKey(indentsKey) {\n  const keyHasTypeSpace = indentsKey[0] === 's';\n  const type = keyHasTypeSpace ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n  const amount = Number(indentsKey.slice(1));\n  return {\n    type,\n    amount\n  };\n} // Return the key (e.g. 's4') from the indents Map that represents the most common indent,\n// or return undefined if there are no indents.\n\n\nfunction getMostUsedKey(indents) {\n  let result;\n  let maxUsed = 0;\n  let maxWeight = 0;\n\n  for (const [key, [usedCount, weight]] of indents) {\n    if (usedCount > maxUsed || usedCount === maxUsed && weight > maxWeight) {\n      maxUsed = usedCount;\n      maxWeight = weight;\n      result = key;\n    }\n  }\n\n  return result;\n}\n\nfunction makeIndentString(type, amount) {\n  const indentCharacter = type === INDENT_TYPE_SPACE ? ' ' : '\\t';\n  return indentCharacter.repeat(amount);\n}\n\nexport default function detectIndent(string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string');\n  } // Identify indents while skipping single space indents to avoid common edge cases (e.g. code comments)\n  // If no indents are identified, run again and include all indents for comprehensive detection\n\n\n  let indents = makeIndentsMap(string, true);\n\n  if (indents.size === 0) {\n    indents = makeIndentsMap(string, false);\n  }\n\n  const keyOfMostUsedIndent = getMostUsedKey(indents);\n  let type;\n  let amount = 0;\n  let indent = '';\n\n  if (keyOfMostUsedIndent !== undefined) {\n    ({\n      type,\n      amount\n    } = decodeIndentsKey(keyOfMostUsedIndent));\n    indent = makeIndentString(type, amount);\n  }\n\n  return {\n    amount,\n    type,\n    indent\n  };\n}","map":{"version":3,"sources":["/Users/xin/Desktop/upload_to_ipfs/node_modules/detect-indent/index.js"],"names":["INDENT_REGEX","INDENT_TYPE_SPACE","INDENT_TYPE_TAB","makeIndentsMap","string","ignoreSingleSpaces","indents","Map","previousSize","previousIndentType","key","line","split","indent","indentType","weight","entry","matches","match","length","indentDifference","absoluteIndentDifference","encodeIndentsKey","get","undefined","set","indentAmount","typeCharacter","String","decodeIndentsKey","indentsKey","keyHasTypeSpace","type","amount","Number","slice","getMostUsedKey","result","maxUsed","maxWeight","usedCount","makeIndentString","indentCharacter","repeat","detectIndent","TypeError","size","keyOfMostUsedIndent"],"mappings":"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","sourcesContent":["// Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment\nconst INDENT_REGEX = /^(?:( )+|\\t+)/;\n\nconst INDENT_TYPE_SPACE = 'space';\nconst INDENT_TYPE_TAB = 'tab';\n\n/**\nMake a Map that counts how many indents/unindents have occurred for a given size and how many lines follow a given indentation.\n\nThe key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.\n\n```\nindents = {\n\tt3: [1, 0],\n\tt4: [1, 5],\n\ts5: [1, 0],\n\ts12: [1, 0],\n}\n```\n*/\nfunction makeIndentsMap(string, ignoreSingleSpaces) {\n\tconst indents = new Map();\n\n\t// Remember the size of previous line's indentation\n\tlet previousSize = 0;\n\tlet previousIndentType;\n\n\t// Indents key (ident type + size of the indents/unindents)\n\tlet key;\n\n\tfor (const line of string.split(/\\n/g)) {\n\t\tif (!line) {\n\t\t\t// Ignore empty lines\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet indent;\n\t\tlet indentType;\n\t\tlet weight;\n\t\tlet entry;\n\t\tconst matches = line.match(INDENT_REGEX);\n\n\t\tif (matches === null) {\n\t\t\tpreviousSize = 0;\n\t\t\tpreviousIndentType = '';\n\t\t} else {\n\t\t\tindent = matches[0].length;\n\t\t\tindentType = matches[1] ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n\n\t\t\t// Ignore single space unless it's the only indent detected to prevent common false positives\n\t\t\tif (ignoreSingleSpaces && indentType === INDENT_TYPE_SPACE && indent === 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (indentType !== previousIndentType) {\n\t\t\t\tpreviousSize = 0;\n\t\t\t}\n\n\t\t\tpreviousIndentType = indentType;\n\n\t\t\tweight = 0;\n\n\t\t\tconst indentDifference = indent - previousSize;\n\t\t\tpreviousSize = indent;\n\n\t\t\t// Previous line have same indent?\n\t\t\tif (indentDifference === 0) {\n\t\t\t\tweight++;\n\t\t\t\t// We use the key from previous loop\n\t\t\t} else {\n\t\t\t\tconst absoluteIndentDifference = indentDifference > 0 ? indentDifference : -indentDifference;\n\t\t\t\tkey = encodeIndentsKey(indentType, absoluteIndentDifference);\n\t\t\t}\n\n\t\t\t// Update the stats\n\t\t\tentry = indents.get(key);\n\t\t\tentry = entry === undefined ? [1, 0] : [++entry[0], entry[1] + weight];\n\n\t\t\tindents.set(key, entry);\n\t\t}\n\t}\n\n\treturn indents;\n}\n\n// Encode the indent type and amount as a string (e.g. 's4') for use as a compound key in the indents Map.\nfunction encodeIndentsKey(indentType, indentAmount) {\n\tconst typeCharacter = indentType === INDENT_TYPE_SPACE ? 's' : 't';\n\treturn typeCharacter + String(indentAmount);\n}\n\n// Extract the indent type and amount from a key of the indents Map.\nfunction decodeIndentsKey(indentsKey) {\n\tconst keyHasTypeSpace = indentsKey[0] === 's';\n\tconst type = keyHasTypeSpace ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n\n\tconst amount = Number(indentsKey.slice(1));\n\n\treturn {type, amount};\n}\n\n// Return the key (e.g. 's4') from the indents Map that represents the most common indent,\n// or return undefined if there are no indents.\nfunction getMostUsedKey(indents) {\n\tlet result;\n\tlet maxUsed = 0;\n\tlet maxWeight = 0;\n\n\tfor (const [key, [usedCount, weight]] of indents) {\n\t\tif (usedCount > maxUsed || (usedCount === maxUsed && weight > maxWeight)) {\n\t\t\tmaxUsed = usedCount;\n\t\t\tmaxWeight = weight;\n\t\t\tresult = key;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction makeIndentString(type, amount) {\n\tconst indentCharacter = type === INDENT_TYPE_SPACE ? ' ' : '\\t';\n\treturn indentCharacter.repeat(amount);\n}\n\nexport default function detectIndent(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Identify indents while skipping single space indents to avoid common edge cases (e.g. code comments)\n\t// If no indents are identified, run again and include all indents for comprehensive detection\n\tlet indents = makeIndentsMap(string, true);\n\tif (indents.size === 0) {\n\t\tindents = makeIndentsMap(string, false);\n\t}\n\n\tconst keyOfMostUsedIndent = getMostUsedKey(indents);\n\n\tlet type;\n\tlet amount = 0;\n\tlet indent = '';\n\n\tif (keyOfMostUsedIndent !== undefined) {\n\t\t({type, amount} = decodeIndentsKey(keyOfMostUsedIndent));\n\t\tindent = makeIndentString(type, amount);\n\t}\n\n\treturn {\n\t\tamount,\n\t\ttype,\n\t\tindent,\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}